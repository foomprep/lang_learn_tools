use clap::Parser;
use serde::Serialize;
use serde_json::Value;
use std::fs;
use std::process::Command;
use std::path::Path;
use std::fs::File;
use std::io::Write;

#[derive(Serialize)]
struct Subtitle {
    text: String,
    media_path: String,
}

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    media: String,
    subtitles: String,
}

fn cut_video(input_path: &str, output_path: &str, start_time: &str, duration: &str) -> Result<(), std::io::Error> {
    let input_path = Path::new(input_path);
    let output_path = Path::new(output_path);

    let status = Command::new("ffmpeg")
        .arg("-ss")
        .arg(start_time)
        .arg("-i")
        .arg(input_path)
        .arg("-t")
        .arg(duration)
        .arg(output_path)
        .status()?;

    if status.success() {
        println!("Video cut successfully");
        Ok(())
    } else {
        Err(std::io::Error::new(std::io::ErrorKind::Other, "FFmpeg failed"))
    }
}

fn main() {
    let args = Args::parse();

    /*
        Subtitles array generated by faster-whisper is structured
        to following spec
            [2] => startTime
            [3] => endTime
            [4] => text
     */
    let subtitles = match fs::read_to_string(&args.subtitles) {
        Ok(content) => content,
        Err(error) => {
            panic!("Failed to read subtitles: {:?}", error);
        }
    };
    let parsed: Vec<Value> = serde_json::from_str(&subtitles).expect("Failed to parse JSON");        

    let home = dirs::home_dir().unwrap();
    for subtitle in parsed {
        let start_time = subtitle[2].as_f64().unwrap() - 0.5;
        let end_time = subtitle[3].as_f64().unwrap() + 0.5;
        let duration = end_time - start_time;
        let text = subtitle[4].as_str().unwrap();

        let media_path = Path::new(&args.media);
        let basename = media_path.file_stem().unwrap().to_str().unwrap();
        let extension = media_path.extension().unwrap().to_str().unwrap();
        let output_path = format!(
            "{}/.flashcard/media/{}_{}.{}", 
            home.to_str().unwrap(), 
            basename, 
            &start_time.to_string(), 
            extension
        );

        let json_output_path = format!(
            "{}/.flashcard/{}_{}.json",
            home.to_str().unwrap(),
            basename,
            &start_time.to_string(),
        );
        let subtitle_json = Subtitle {
            text: text.to_string(),
            media_path: output_path.clone(),
        };
        let serialized_subtitle_json = serde_json::to_string(&subtitle_json).unwrap();
        let mut file = File::create(json_output_path).unwrap();
        file.write_all(serialized_subtitle_json.as_bytes()).unwrap();

        cut_video(
            &args.media, 
            &output_path, 
            &start_time.to_string(), 
            &duration.to_string()
        ).unwrap();
    }
}

