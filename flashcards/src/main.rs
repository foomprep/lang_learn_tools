use clap::Parser;
use serde::Serialize;
use serde_json::Value;
use std::fs;
use std::process::Command;
use std::path::Path;
use std::fs::File;
use std::io::Write;

#[derive(Serialize)]
struct Subtitle {
    text: String,
    media_path: String,
}

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    media: String,
    subtitles: String,
}

fn cut_video(input_path: &str, output_path: &str, start_time: &str, duration: &str) -> Result<(), std::io::Error> {
    let input_path = Path::new(input_path);
    let output_path = Path::new(output_path);

    let status = Command::new("ffmpeg")
        .arg("-ss")
        .arg(start_time)
        .arg("-i")
        .arg(input_path)
        .arg("-t")
        .arg(duration)
        .arg(output_path)
        .status()?;

    if status.success() {
        println!("Video cut successfully");
        Ok(())
    } else {
        Err(std::io::Error::new(std::io::ErrorKind::Other, "FFmpeg failed"))
    }
}

// fn extract_audio_from_video(video_path: &Path) -> Result<PathBuf, Box<dyn std::error::Error>> {
//     // Create the output path (same name as input, but with .wav extension)
//     let output_path = video_path.with_extension("wav");

//     // Construct the ffmpeg command
//     let output = Command::new("ffmpeg")
//         .arg("-i")
//         .arg(video_path)
//         .arg("-vn")  // Disable video output
//         .arg("-acodec")
//         .arg("pcm_s16le")  // Use 16-bit PCM audio codec
//         .arg("-ar")
//         .arg("16000")  // Set audio sampling rate to 44.1kHz
//         .arg("-ac")
//         .arg("2")  // Set to stereo (2 channels)
//         .arg("-y")  // Overwrite output file if it exists
//         .arg(&output_path)
//         .output()?;

//     // Check if the command was successful
//     if !output.status.success() {
//         let error_message = String::from_utf8_lossy(&output.stderr);
//         return Err(format!("FFmpeg command failed: {}", error_message).into());
//     }

//     Ok(output_path)
// }

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    /*
        Subtitles array generated by faster-whisper is structured
        to following spec
            [2] => startTime
            [3] => endTime
            [4] => text
     */
    let subtitles = match fs::read_to_string(&args.subtitles) {
        Ok(content) => content,
        Err(error) => {
            panic!("Failed to read subtitles: {:?}", error);
        }
    };
    let parsed: Vec<Value> = serde_json::from_str(&subtitles).expect("Failed to parse JSON");        

    let home = match dirs::home_dir() {
        Some(p) => p,
        None => panic!("Could not retrieve home directory"),
    };

    for subtitle in parsed {
        let start_time = match subtitle[2].as_f64() {
            Some(time) => time - 0.5,
            None => panic!("Could not convert subtitle[2] to f64")
        };
        let end_time = match subtitle[3].as_f64() {
            Some(time) => time + 0.5,
            None => panic!("Could not convert subtitle[3] to f64")
        };
        let duration = end_time - start_time;
        let text = match subtitle[4].as_str() {
            Some(text) => text,
            None => panic!("Could not covert subtitle[4] to str")
        };

        let media_path = Path::new(&args.media);
        let basename = match media_path.file_stem() {
            Some(stem) => {
                match stem.to_str() {
                    Some(stem_str) => stem_str,
                    None => panic!("Could not convert OsStr to str")
                }
            },
            None => panic!("Could not get file_stem of media_path")
        };
        let extension = match media_path.extension() {
            Some(stem) => {
                match stem.to_str() {
                    Some(stem_str) => stem_str,
                    None => panic!("Could not convert OsStr to str")
                }
            },
            None => panic!("Could not get file_stem of media_path")
        };
        let home_string = match home.to_str() {
            Some(s) => s,
            None => panic!("Could not convert home path to str")
        };
        let output_path = format!(
            "{}/.flashcard/media/{}_{}.{}", 
            home_string, 
            basename, 
            &start_time.to_string(), 
            extension
        );

        let json_output_path = format!(
            "{}/.flashcard/{}_{}.json",
            home_string,
            basename,
            &start_time.to_string(),
        );
        let subtitle_json = Subtitle {
            text: text.to_string(),
            media_path: output_path.clone(),
        };
        let serialized_subtitle_json = serde_json::to_string(&subtitle_json)?;
        let mut file = File::create(json_output_path)?;
        file.write_all(serialized_subtitle_json.as_bytes())?;

        // TODO launch on separate threads adn resume loop
        cut_video(
            &args.media, 
            &output_path, 
            &start_time.to_string(), 
            &duration.to_string()
        )?;
    }

    Ok(())
}

